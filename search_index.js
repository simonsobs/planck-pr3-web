var documenterSearchIndex = {"docs":
[{"location":"setup.html","page":"setup.jl","title":"setup.jl","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov//src/setup.jl\"","category":"page"},{"location":"setup.html","page":"setup.jl","title":"setup.jl","text":"# all examples are run on an example global.toml and downsized maps.\nARGS = [\"example.toml\"]","category":"page"},{"location":"setup.html#setup","page":"setup.jl","title":"Setup (setup.jl)","text":"","category":"section"},{"location":"setup.html","page":"setup.jl","title":"setup.jl","text":"This pipeline is written in Julia, so you will need a Julia installation in order to run the components. We recommend you use the precompiled binaries provided on the Julia website. Make sure to add the Julia executable to your path, as described in the platform-specific instructions.","category":"page"},{"location":"setup.html#Package-Installation","page":"setup.jl","title":"Package Installation","text":"","category":"section"},{"location":"setup.html","page":"setup.jl","title":"setup.jl","text":"We use the package manager in the Julia interpeter to install the latest versions of Healpix and PowerSpectra. This will be simpler in the future, when we tag a stable version of these packages for the General Registry. For now, we add the latest versions of these packages from GitHub. Note that package installation requires an internet connection, so unlike the other parts of the pipeline, setup.jl requires an internet connection. If you're on a cluster, that means you need to run this file on the head node in order to install packages.","category":"page"},{"location":"setup.html","page":"setup.jl","title":"setup.jl","text":"using Pkg\nPkg.add.([\"Healpix\", \"PowerSpectra\", \"CSV\", \"DataFrames\", \"TOML\",\n  \"BlackBoxOptim\", \"FileIO\", \"JLD2\", \"FITSIO\",\n  \"DataInterpolations\", \"Optim\", \"GaussianProcesses\"])","category":"page"},{"location":"setup.html","page":"setup.jl","title":"setup.jl","text":"The command-line interface for this basic pipeline setup script is","category":"page"},{"location":"setup.html","page":"setup.jl","title":"setup.jl","text":"<pre class=\"shell\">\n<code class=\"language-shell hljs\">$ julia setup.jl global.toml</code></pre>","category":"page"},{"location":"setup.html","page":"setup.jl","title":"setup.jl","text":"It displays the contents of the global TOML configuration file named global.toml.\nThis script downloads the Planck data to the specified directories in global.toml.","category":"page"},{"location":"setup.html#Configuration","page":"setup.jl","title":"Configuration","text":"","category":"section"},{"location":"setup.html","page":"setup.jl","title":"setup.jl","text":"All of the pipeline scripts take a configuration TOML file as the first argument. We now print out just the [dir] entry in the TOML, which is what you will need to configure.","category":"page"},{"location":"setup.html","page":"setup.jl","title":"setup.jl","text":"using TOML\nconfigfile = ARGS[1]  # read in the first command line argument\nprintln(\"config filename: \", configfile, \"\\n\")\n\n# take a look at the config\nconfig = TOML.parsefile(configfile)\nTOML.print(Dict(\"dir\"=>config))  # print just the \"dir\" TOML entry","category":"page"},{"location":"setup.html","page":"setup.jl","title":"setup.jl","text":"The scratch space is where intermediary files are deposited.\nNote that each map file has an identifier. This shortens the long names, but more importantly allows one to set up a custom system of names when we cross-correlate Planck with other experiments.\nIn this case, we preface all Planck maps and masks with P, and include the frequency and split.","category":"page"},{"location":"setup.html#Downloading-the-Planck-2018-Data","page":"setup.jl","title":"Downloading the Planck 2018 Data","text":"","category":"section"},{"location":"setup.html","page":"setup.jl","title":"setup.jl","text":"# set up download urls\nusing Downloads\n\nif length(ARGS) == 0\n    TARGET_DIR = pwd()\nelse\n    TARGET_DIR = ARGS[1]\nend\n\n# set up directories\nmapdest = joinpath(config[\"scratch\"], \"maps\")\nmaskdest = joinpath(config[\"scratch\"], \"masks\")\nbeamdest = joinpath(config[\"scratch\"], \"beams\")\nmkpath(mapdest)\nmkpath(maskdest)\nmkpath(beamdest)\n\nfunction download_if_necessary(url, dest; verbose=true)\n    if isfile(dest) == false\n        verbose && println(\"Downloading \", dest)\n        @time Downloads.download(url, dest)\n    else\n        verbose && println(\"Extant, skip \", dest)\n    end\nend","category":"page"},{"location":"setup.html","page":"setup.jl","title":"setup.jl","text":"# now read from config and then actually download\nmapfiles = values(config[\"map\"])\nmaskfiles = [values(config[\"maskT\"])..., values(config[\"maskP\"])...]\n\nfor f in mapfiles\n    download_if_necessary(joinpath(config[\"url\"][\"maps\"], f), joinpath(mapdest, f))\nend\n\nfor f in maskfiles\n    download_if_necessary(joinpath(config[\"url\"][\"masks\"], f), joinpath(maskdest, f))\nend\n\n# just download beamfile to the target directory base.\nbeamfile = \"HFI_RIMO_BEAMS_R3.01.tar.gz\"\nfullbeamfile = joinpath(beamdest, beamfile)\ndownload_if_necessary(joinpath(config[\"url\"][\"beams\"], beamfile), fullbeamfile)\nrun(`cp $(fullbeamfile) $(joinpath(beamdest, \"tempbeamgz\"))`)\nrun(`gzip -f -d $(joinpath(beamdest, beamfile))`)\nrun(`mv $(joinpath(beamdest, \"tempbeamgz\")) $(fullbeamfile)`)\nbeamfiletar = replace(beamfile, \".tar.gz\"=>\".tar\")\nrun(`tar -xf $(joinpath(beamdest, beamfiletar)) --overwrite -C $(beamdest)`);\nnothing #hide","category":"page"},{"location":"setup.html","page":"setup.jl","title":"setup.jl","text":"# We also want to retrieve the plic templates.\nplicrefdir = joinpath(config[\"scratch\"])\nplicreffile = joinpath(config[\"scratch\"], \"plicref.tar.gz\")\ndownload_if_necessary(\n    \"https://github.com/xzackli/PSPipePlanckRender.jl/releases/download/0.1.2/plicref.tar.gz\",\n    plicreffile)\nrun(`tar -xzvf $(plicreffile) --overwrite -C $(plicrefdir)`);\nnothing #hide","category":"page"},{"location":"setup.html","page":"setup.jl","title":"setup.jl","text":"sims","category":"page"},{"location":"setup.html","page":"setup.jl","title":"setup.jl","text":"using Healpix\nHealpix.applyFullWeights!(HealpixMap{Float64, RingOrder}(2048))\nusing PowerSpectra\nPowerSpectra.planck256_beamdir()","category":"page"},{"location":"corrections.html","page":"corrections.jl","title":"corrections.jl","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov//src/corrections.jl\"","category":"page"},{"location":"corrections.html","page":"corrections.jl","title":"corrections.jl","text":"# the example command line input for this script\nARGS = [\"example.toml\", \"143\", \"143\", \"TT\", \"--plot\"]","category":"page"},{"location":"corrections.html#corrections","page":"corrections.jl","title":"Corrections for Point Sources (corrections.jl)","text":"","category":"section"},{"location":"corrections.html","page":"corrections.jl","title":"corrections.jl","text":"configfile, freq1, freq2, spec = ARGS\n\nfreqs = [freq1, freq2]\nsplits = [\"1\", \"2\"]\nprint(\"$(freqs[1]), $(freqs[2]), $(spec)\\n\")\n\ntransposed = (spec == \"ET\")\nif transposed\n    spec = \"TE\"\n    splits = reverse(splits)\n    freqs = reverse(freqs)\nend\n\n\nusing Plots\nusing PowerSpectra\nusing TOML\nusing UUIDs, JLD2, FileIO\nusing Statistics\nusing GaussianProcesses\n\ninclude(\"util.jl\")\n\nconfig = TOML.parsefile(configfile)\nnside = config[\"general\"][\"nside\"]\nrun_name = config[\"general\"][\"name\"]\nsimpath = joinpath(config[\"scratch\"], \"signalsims\",\n    \"$(freq1)_$(freq2)_$(spec)\")\nlmax = nside2lmax(nside)\nlmax_planck = min(2508, lmax)\n\nfunction readsims(path)\n    files = [f for f in readdir(simpath; join=false) if f != \"summary.jld2\"]\n    test_spec_ = load(joinpath(path,files[1]), \"cl\")\n    cl_array = zeros((length(test_spec_), length(files)))\n    for (i,f) in enumerate(files)\n        cl_array[:,i] .= parent(load(joinpath(path,f), \"cl\"))\n    end\n    return cl_array\nend\n\n\n@time cl_array = readsims(simpath)\ncl_mean = mean(cl_array, dims=2)\ncl_var = var(cl_array, dims=2)\n@save joinpath(simpath, \"summary.jld2\") cl_mean cl_var\n\nsignal11, th = signal_and_theory(freq1, freq1, config)\nsignal12, th = signal_and_theory(freq1, freq2, config)\nsignal21, th = signal_and_theory(freq2, freq1, config)\nsignal22, th = signal_and_theory(freq2, freq2, config)\n\n#\nif \"--plot\" ‚àà ARGS\n    plot(cl_mean[1:lmax_planck+1] .* collect(0:lmax_planck).^2,\n        yerr=(sqrt.(cl_var[1:lmax_planck+1])  .* collect(0:lmax_planck).^2), alpha=0.5)\n    plot!(signal12[spec] .* collect(0:length(signal11[spec])-1).^2, xlim=(0,2nside))\nend","category":"page"},{"location":"corrections.html","page":"corrections.jl","title":"corrections.jl","text":"#\nX, Y = Symbol(spec[1]), Symbol(spec[2])\nrun_name = config[\"general\"][\"name\"]\nmasktype1 = (X == :T) ? \"T\" : \"P\"\nmasktype2 = (Y == :T) ? \"T\" : \"P\"\nmapid1 = \"P$(freq1)hm$(splits[1])\"\nmapid2 = \"P$(freq2)hm$(splits[2])\"","category":"page"},{"location":"corrections.html","page":"corrections.jl","title":"corrections.jl","text":"using Healpix\nmaskfileT‚ÇÅ = joinpath(config[\"scratch\"], \"masks\", \"$(run_name)_$(mapid1)_maskT.fits\")\nmaskfileP‚ÇÅ = joinpath(config[\"scratch\"], \"masks\", \"$(run_name)_$(mapid1)_maskP.fits\")\nmaskfileT‚ÇÇ = joinpath(config[\"scratch\"], \"masks\", \"$(run_name)_$(mapid2)_maskT.fits\")\nmaskfileP‚ÇÇ = joinpath(config[\"scratch\"], \"masks\", \"$(run_name)_$(mapid2)_maskP.fits\")\n\nmaskT‚ÇÅ = readMapFromFITS(maskfileT‚ÇÅ, 1, Float64)\nmaskP‚ÇÅ = readMapFromFITS(maskfileP‚ÇÅ, 1, Float64)\nmaskT‚ÇÇ = readMapFromFITS(maskfileT‚ÇÇ, 1, Float64)\nmaskP‚ÇÇ = readMapFromFITS(maskfileP‚ÇÇ, 1, Float64);\n\nzero_var_component = HealpixMap{Float64, RingOrder}(zeros(nside2npix(nside)))\nzero_var = PolarizedHealpixMap(zero_var_component, zero_var_component, zero_var_component);\n\nm1_signal = CovField(mapid1, maskT‚ÇÅ, maskP‚ÇÅ, zero_var)\nm2_signal = CovField(mapid2, maskT‚ÇÇ, maskP‚ÇÇ, zero_var)","category":"page"},{"location":"corrections.html","page":"corrections.jl","title":"corrections.jl","text":"convert a Vector (starting from 0) into a SpectralVector of full length","category":"page"},{"location":"corrections.html","page":"corrections.jl","title":"corrections.jl","text":"function format_signal(v::Vector{T}, nside) where T\n    result = SpectralVector(zeros(T, nside2lmax(nside)+1))\n    last_ind = min(length(v), length(result)) - 1\n    for ‚Ñì in 0:last_ind\n        result[‚Ñì] = v[‚Ñì + 1]\n    end\n    return result\nend\n\n\nspectra = Dict{SpectrumName, SpectralVector{Float64, Vector{Float64}}}(\n    (:TT, mapid1, mapid1) => format_signal(signal11[\"TT\"], nside),\n    (:TT, mapid1, mapid2) => format_signal(signal12[\"TT\"], nside),\n    (:TT, mapid2, mapid1) => format_signal(signal21[\"TT\"], nside),\n    (:TT, mapid2, mapid2) => format_signal(signal22[\"TT\"], nside),\n\n    (:EE, mapid1, mapid1) => format_signal(signal11[\"EE\"], nside),\n    (:EE, mapid1, mapid2) => format_signal(signal12[\"EE\"], nside),\n    (:EE, mapid2, mapid1) => format_signal(signal21[\"EE\"], nside),\n    (:EE, mapid2, mapid2) => format_signal(signal22[\"EE\"], nside),\n\n    (:TE, mapid1, mapid1) => format_signal(signal11[\"TE\"], nside),\n    (:TE, mapid1, mapid2) => format_signal(signal12[\"TE\"], nside),\n    (:TE, mapid2, mapid1) => format_signal(signal21[\"TE\"], nside),\n    (:TE, mapid2, mapid2) => format_signal(signal22[\"TE\"], nside),\n);\n\nworkspace_signal = CovarianceWorkspace(m1_signal, m2_signal, m1_signal, m2_signal);\n\n@time C = coupledcov(Symbol(spec), Symbol(spec), workspace_signal, spectra)\n\nsymspec = (spec == \"EE\") ? :M‚Å∫‚Å∫ : Symbol(spec)\nmask‚ÇÅ = (spec[1] == 'T') ? maskT‚ÇÅ : maskP‚ÇÅ\nmask‚ÇÇ = (spec[2] == 'T') ? maskT‚ÇÇ : maskP‚ÇÇ\n@time ùêå = mcm(symspec, mask‚ÇÅ, mask‚ÇÇ)\nC_decoupled = decouple_covmat(C, ùêå, ùêå)","category":"page"},{"location":"corrections.html","page":"corrections.jl","title":"corrections.jl","text":"the covariance is possibly transposed, but we only care about the diagonal","category":"page"},{"location":"corrections.html","page":"corrections.jl","title":"corrections.jl","text":"correction = SpectralVector(cl_var[:,1] ./ diag(parent(C_decoupled)))\n\nlmin_cut, lmax_cut = get_plic_ellrange(Symbol(spec), freq1, freq2)\ncorrection[lmax_cut:end] .= 1.0\n\nfit_ells = intersect((lmin_cut-20):(lmax_cut), 0:lmax)\nu = correction[fit_ells] .- 1\nt = 1.0 * collect(fit_ells)","category":"page"},{"location":"corrections.html","page":"corrections.jl","title":"corrections.jl","text":"Set-up mean and kernel","category":"page"},{"location":"corrections.html","page":"corrections.jl","title":"corrections.jl","text":"se = SE(0.0, 0.0)\nm = MeanZero()\ngp = GP(t,u,m,se)\n\nusing Optim\noptimize!(gp)   # Optimise the hyperparameters\ncorrection_gp = predict_y(gp,float.(0:(lmax_cut+20)))[1];\ncorrection_gp[1:(lmin_cut-21)] .= 0.0\n\ncorrection_path = joinpath(config[\"scratch\"], \"point_source_corrections\")\nmkpath(correction_path)\n\nif transposed\n    revspec = reverse(spec)\n    correction_file = joinpath(correction_path, \"$(freq1)_$(freq2)_$(revspec)_corr.dat\")\nelse\n    correction_file = joinpath(correction_path, \"$(freq1)_$(freq2)_$(spec)_corr.dat\")\nend\nwritedlm(correction_file, correction_gp)","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov//src/rawspectra.jl\"","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"# the example command line input for this script\nARGS = [\"example.toml\", \"P143hm1\", \"P143hm2\", \"--plot\"]","category":"page"},{"location":"rawspectra.html#rawspectra","page":"rawspectra.jl","title":"Raw Spectra (rawspectra.jl)","text":"","category":"section"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"The first step in the pipeline is simply to compute the pseudo-spectrum between the maps X and Y. We define the pseudo-spectrum widetildeC_ell as the result of the estimator on spherical harmonic coefficients of the masked sky,","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"widetildeC_ell = frac12ell+1 sum_m a^iX_ell m a^jY_ell m","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"Since we mask the galaxy and point sources, this is a biased estimate of the underlying power spectrum. The mask couples modes together, and also removes power from parts of the sky. This coupling is described by a linear operator mathbfM, the mode-coupling matrix. For more details on spectra and mode-coupling, please refer to the documentation for PowerSpectra.jl. If this matrix is known, then one can perform a linear solve to obtain an unbiased estimate of the underlying power spectrum C_ell,","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"langlewidetildeC_ellrangle =\nmathbfM^XY(ij)_ell_1 ell_2 langle C_ell rangle","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"This script performs this linear solve, without accounting for beams. The noise spectra are estimated from the difference of auto- and cross-spectra, The command-line syntax for using this component to compute mode-coupled spectra is","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"<pre class=\"shell\">\n<code class=\"language-shell hljs\">$ julia rawspectra.jl global.toml [map1] [map2]</code></pre>","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"[map1] and [map2] must be names of maps described in global.toml.","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"This page shows the results of running the command","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"<pre class=\"shell\">\n<code class=\"language-shell hljs\">$ julia src/rawspectra.jl example.toml P143hm1 P143hm2</code></pre>","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"The first step is just to unpack the command-line arguments, which consist of the TOML config file and the map names, which we term channels 1 and 2.","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"configfile, mapid1, mapid2 = ARGS","category":"page"},{"location":"rawspectra.html#File-Loading-and-Cleanup","page":"rawspectra.jl","title":"File Loading and Cleanup","text":"","category":"section"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"We start by loading the necessary packages.","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"using TOML\nusing Healpix\nusing PowerSpectra\nusing Plots","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"config = TOML.parsefile(configfile)","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"For both input channels, we need to do some pre-processing steps.","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"We first load in the I, Q, and U Stokes vectors, which are FITS columns 1, 2, and 3 in the Planck map files. These must be converted from nested to ring ordered, to perform SHTs.\nWe read in the corresponding masks in temperature and polarization.\nWe zero the missing pixels in the maps, and also zero the corresponding pixels in the masks.\nWe convert from mathrmK_mathrmCMB to mu mathrmK_mathrmCMB.\nApply a small polarization amplitude adjustment, listed as poleff in the config.\nWe also remove some noisy pixels with mathrmsigma(Q)  10^6mumathrmK^2 or mathrmsigma(U)  10^6mumathrmK^2, or if they are negative. This removes a handful of pixels in the 2018 maps at 100 GHz which interfere with covariance estimation.\nEstimate and subtract the pseudo-monopole and pseudo-dipole.","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"\"\"\"Return (polarized map, maskT, maskP) given a config and map identifier\"\"\"\nfunction load_maps_and_masks(config, mapid, maptype=Float64)\n    # read map file\n    println(\"Reading \", config[\"map\"][mapid])\n    mapfile = joinpath(config[\"scratch\"], \"maps\", config[\"map\"][mapid])\n    polmap = PolarizedHealpixMap(\n        nest2ring(readMapFromFITS(mapfile, 1, maptype)),  # I\n        nest2ring(readMapFromFITS(mapfile, 2, maptype)),  # Q\n        nest2ring(readMapFromFITS(mapfile, 3, maptype)))  # U\n\n    # read maskT and maskP\n    maskfileT = joinpath(config[\"scratch\"], \"masks\", config[\"maskT\"][mapid])\n    maskfileP = joinpath(config[\"scratch\"], \"masks\", config[\"maskP\"][mapid])\n    maskT = readMapFromFITS(maskfileT, 1, maptype)\n    maskP = readMapFromFITS(maskfileP, 1, maptype)\n\n    # read Q and U pixel variances, and convert to ŒºK\n    covQQ = nest2ring(readMapFromFITS(mapfile, 8, maptype)) .* 1e12\n    covUU = nest2ring(readMapFromFITS(mapfile, 10, maptype)) .* 1e12\n\n    # identify missing pixels and also pixels with crazy variances\n    for p in eachindex(maskT)\n        if (polmap.i[p] < -1.6e30) | (covQQ[p] > 1e6) | (covUU[p] > 1e6) |\n                (covQQ[p] < 0) | (covUU[p] < 0)\n            maskT[p] = 0.\n            maskP[p] = 0.\n        end\n    end\n\n    # go from KCMB to ŒºKCMB, and apply polarization factor\n    poleff = config[\"poleff\"][mapid]\n    scale!(polmap, 1e6, 1e6 * poleff)  # apply 1e6 to (I) and 1e6 * poleff to (Q,U)\n\n    # fit and remove pseudo-monopole/dipole in I\n    monopole, dipole = fitdipole(polmap.i * maskT)\n    subtract_monopole_dipole!(polmap.i, monopole, dipole)\n\n    return polmap, maskT, maskP\nend","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"We'll use this function for the half-missions involved here.","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"m‚ÇÅ, maskT‚ÇÅ, maskP‚ÇÅ = load_maps_and_masks(config, mapid1)\nm‚ÇÇ, maskT‚ÇÇ, maskP‚ÇÇ = load_maps_and_masks(config, mapid2)\nplot(m‚ÇÅ.i, clim=(-200,200))  # plot the intensity map","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"if \"--plot\" ‚àà ARGS\n    plot(maskT‚ÇÅ)  # show the temperature mask\nend","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"run_name = config[\"general\"][\"name\"]\nfunction save_if_needed(mapobj, mapfile)\n    if isfile(mapfile) == false\n        saveToFITS(mapobj, mapfile)\n    end\nend\n\nsave_if_needed(maskT‚ÇÅ, joinpath(config[\"scratch\"], \"masks\", \"$(run_name)_$(mapid1)_maskT.fits\"))\nsave_if_needed(maskP‚ÇÅ, joinpath(config[\"scratch\"], \"masks\", \"$(run_name)_$(mapid1)_maskP.fits\"))\nsave_if_needed(maskT‚ÇÇ, joinpath(config[\"scratch\"], \"masks\", \"$(run_name)_$(mapid2)_maskT.fits\"))\nsave_if_needed(maskP‚ÇÇ, joinpath(config[\"scratch\"], \"masks\", \"$(run_name)_$(mapid2)_maskP.fits\"))","category":"page"},{"location":"rawspectra.html#Computing-Spectra-and-Saving","page":"rawspectra.jl","title":"Computing Spectra and Saving","text":"","category":"section"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"Once you have cleaned up maps and masks, you compute the calculation is described in PowerSpectra - Mode Coupling. That package has a utility function master that performs the full MASTER calculation on two IQU maps with associated masks.","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"# do the mode coupling on all T, E, and B spectra\nCl = master(m‚ÇÅ, maskT‚ÇÅ, maskP‚ÇÅ,\n            m‚ÇÇ, maskT‚ÇÇ, maskP‚ÇÇ)\nnside = maskT‚ÇÅ.resolution.nside  # get the resolution from any of the maps\nlmax = nside2lmax(nside)\nprintln(keys(Cl))  # check what spectra were computed","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"The PowerSpectra.jl package has the Planck bestfit theory and beams as utility functions, for demo and testing purposes. We can use it that for plotting here.","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"if \"--plot\" ‚àà ARGS\n    spec = :TT\n    Wl = PowerSpectra.planck_beam_Wl(\"143\", \"hm1\", \"143\", \"hm2\", spec, spec; lmax=lmax)\n    pixwinT = SpectralVector(pixwin(nside)[1:(lmax+1)])\n    ell = eachindex(Wl)\n    prefactor = ell .* (ell .+ 1) ./ (2œÄ)\n    plot( prefactor .*  Cl[spec] ./ (Wl .* pixwinT.^2),\n        label=\"\\$D_{\\\\ell}\\$\", xlim=(0,2nside))\n    theory = PowerSpectra.planck_theory_Dl()\n    plot!(theory[spec], label=\"theory $(spec)\")\nend","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"Now we save our spectra.","category":"page"},{"location":"rawspectra.html","page":"rawspectra.jl","title":"rawspectra.jl","text":"# set up spectra path\nusing CSV, DataFrames\nspectrapath = joinpath(config[\"scratch\"], \"rawspectra\")\nmkpath(spectrapath)\n\n# assemble a table with the ells and spectra\ndf = DataFrame()\ndf[!,:ell] = eachindex(Cl[first(keys(Cl))])\nfor spec in keys(Cl)\n    df[!,spec] = parent(Cl[spec])\nend\n\nCSV.write(joinpath(spectrapath, \"$(run_name)_$(mapid1)x$(mapid2).csv\"), df)","category":"page"},{"location":"binning.html","page":"-","title":"-","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov//src/binning.jl\"","category":"page"},{"location":"binning.html","page":"-","title":"-","text":"# all examples are run on an example global.toml and downsized maps.\nARGS = [\"example.toml\"]","category":"page"},{"location":"binning.html","page":"-","title":"-","text":"configfile = ARGS[1]\n\n# get modules and utility functions\nusing Plots\nusing TOML\nusing Healpix\ninclude(\"util.jl\")\n\nconfig = TOML.parsefile(configfile)\nnside = config[\"general\"][\"nside\"]\nlmax = nside2lmax(nside)\n\npl = PlanckReferenceCov(joinpath(config[\"scratch\"], \"plicref\"))\n\n# read binning scheme\nbinfile = joinpath(@__DIR__, \"../\", \"input\", \"binused.dat\")\nP, lb = util_planck_binning(binfile; lmax=lmax);\n\n#\nfreq1, freq2 = \"100\", \"100\"\nWl = util_planck_beam_Wl(freq1, \"hm1\", freq2, \"hm2\", :EE, :EE;\n    lmax=lmax, beamdir=joinpath(config[\"scratch\"], \"beams\"))\nplot(Wl, yaxis=:log10, label=\"\\$B_{\\\\ell}\\$\")\n\n#\nrun_name = config[\"general\"][\"name\"]\nmapids = [k for k in keys(config[\"map\"])]\nspectrapath = joinpath(config[\"scratch\"], \"rawspectra\")\n\nmapid1 = \"P$(freq1)hm1\"\nmapid2 = \"P$(freq2)hm2\"\nspec = CSV.read(joinpath(spectrapath,\"$(run_name)_$(mapid1)x$(mapid2).csv\"), DataFrame)\nplot(spec.ell, spec.ell.^2 .* spec.EE, label=\"$(run_name)_$(mapid1)x$(mapid2)\",\n    xlabel=\"multipole moment\", ylabel=\"\\$\\\\ell^2 C_{\\\\ell}^{EE}\\$\", xlim=(0,2nside))\n\n#\nlbref, cbref, err_ref, _ = extract_spec_and_cov(pl, \"EE_$(freq1)x$(freq2)\")\n\n#\ncl = SpectralVector(copy(spec.EE))\nthis_lmax = max(lastindex(cl), lastindex(Wl))\npixwinT, pixwinP = pixwin(nside; pol=true)\ncl[0:this_lmax] ./= Wl[0:this_lmax] .* pixwinP[1:(this_lmax+1)].^2\ncl[0:1] .= 0.0\ncb = P * parent(cl)\nplanck_bin_choice = findfirst(lb .‚â• lbref[1]):findlast(lb .‚â§ lbref[end])\n\nnside_cut = 1:length(planck_bin_choice)\nplot(lb[planck_bin_choice], (cb[planck_bin_choice] .- cbref[nside_cut]) ./ err_ref[nside_cut],\n    ylim=(-2,2), label=label=\"$(run_name)_$(mapid1)x$(mapid2)\")","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov//src/covmat.jl\"","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"# the example command line input for this script\nARGS = [\"example.toml\", \"143\", \"143\", \"143\", \"143\", \"T\", \"T\", \"T\", \"T\", \"1\", \"2\", \"1\", \"2\", \"--plot\"]","category":"page"},{"location":"covmat.html#covmat","page":"covmat.jl","title":"Covariance Matrix Estimation (covmat.jl)","text":"","category":"section"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"This part of the pipeline dominates the total computational cost. Many of the steps like spectra estimation could have been run on a laptop, but estimating the covariance for the full Planck data vector involves computing sim 10^3 covariance matrix blocks. The covariance matrix involves four fields, and those fields each have a frequency, channel, and map split. We thus need every combination of frequencies f_1, f_2, f_3, f_4 for f_i in  100 143 217  with channels A, B, C, D for X_i in T E, and splits s_1, s_2, s_3, s_4 for s_i in  mathrmhm1 mathrmhm2 .","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"These are the inputs for the command line interface for this script, covmat.jl.","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"<pre class=\"shell\">\n<code class=\"language-shell hljs\">$ julia covmat.jl global.toml f1 f2 f3 f3 X1 X2 X3 X4 s1 s2 s3 s4 --plot</code></pre>","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"As usual, the --plot argument is optional.","category":"page"},{"location":"covmat.html#Setup","page":"covmat.jl","title":"Setup","text":"","category":"section"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"As usual, we need to load up our dependencies and then unpack the command line arguments into variables. We'll keep the freqs, specs, and splits as just arrays of strings for now.","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"freqs = [ARGS[2], ARGS[3], ARGS[4], ARGS[5]]\nspecs = [ARGS[6], ARGS[7], ARGS[8], ARGS[9]]\nsplits = [ARGS[10], ARGS[11], ARGS[12], ARGS[13]]\n\nusing TOML\nusing PowerSpectra\nusing Healpix\nusing JLD2\nusing Plots\ninclude(\"util.jl\")","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"As usual, we get some general information from the configuration file specified as the first command line argument.","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"configfile = ARGS[1]\nconfig = TOML.parsefile(configfile)\nnside = config[\"general\"][\"nside\"]\nlmax = nside2lmax(nside)\nlmax_planck = min(2508, lmax)\nrun_name = config[\"general\"][\"name\"]","category":"page"},{"location":"covmat.html#Change-to-canonical-ordering","page":"covmat.jl","title":"Change to canonical ordering","text":"","category":"section"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"The covariance matrix is over fields F_1, F_2, F_3, F_4 and represents the covariance between the langle F_1 F_2 rangle and langle F_3 times F_4 rangle cross-spectra. However, the covariance matrix is invariant when swapping F_1 leftrightarrow F_2 as well as F_3 leftrightarrow F_4. Under the transformation that swaps the first pair for the second pair (i.e. F_1 leftrightarrow F_3 and F_2 leftrightarrow F_4 simultaneously), the covariance matrix is transposed.","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"Given these convenient properties, we define a canonical ordering of the fields in a covariance matrix. We insist that no temperature field can ever be after a polarization field in an ordering. Thus, we don't need to implement an expression for a TETT covariance, because it can always be transformed into the canonical TTTE (this example requires a transposition pf the matrix at the end). We'll write a few utility functions to enable these transformations here.","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"# This utility tests if it's not a temperature channel\nispol(spec_str) = (spec_str == \"T\") ? 0 : 1\n\nfunction swap!(specs, freqs, splits, i, j)\n    specs[i], specs[j] = specs[j], specs[i]\n    freqs[i], freqs[j] = freqs[j], freqs[i]\n    splits[i], splits[j] = splits[j], splits[i]\nend\n\n# canonical form: T as far left as possible\n\n\"\"\"\n    canonical!(specs, freqs, splits)\n\nGiven four fields, described by length-4 arrays of specs (T, E), freqs, and splits,\nmodify these input arrays so they are in the canonical ordering, i.e. with\ntemperature fields before polarization.\n\n### Arguments:\n- `specs`: array of four strings, containing \"T\" and \"E\" elements\n- `freqs`: array of four frequencies\n- `splits`: array of four choices of data split\n\n### Returns:\n- `Boolean`: some canonical orderings are a matrix transpose of the inputs. If this\n    function returns true, then one needs to perform this transposition.\n\"\"\"\nfunction canonical!(specs, freqs, splits)\n    transposed = false\n\n    if sum(ispol.(specs[1:2])) > sum(ispol.(specs[3:4]))\n        swap!(specs, freqs, splits, 1, 3)\n        swap!(specs, freqs, splits, 2, 4)\n        transposed = true\n    end\n    if specs[1] == \"E\" && specs[2] == \"T\"\n        swap!(specs, freqs, splits, 1, 2)\n    end\n    if specs[3] == \"E\" && specs[4] == \"T\"\n        swap!(specs, freqs, splits, 3, 4)\n    end\n\n    return transposed\nend","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"We re-arrange the specs, freqs, and splits spectra so they are in the canonical ordering. We save whether we need to transpose the result.","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"transposed = canonical!(specs, freqs, splits)\n@show specs freqs splits transposed\n\n# convenience names since we looking for covariance between AB and CD spectra\nspecAB = Symbol(specs[1]*specs[2])\nspecCD = Symbol(specs[3]*specs[4])\n@show specAB specCD","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"Next, we need to create dictionaries that contain the fruits of our labors from earlier parts of the pipeline. These include the theory spectra, the ratio of the noise power spectrum to the white noise power spectrum.","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"# store info needed for covariance calculations\nspectra = Dict{SpectrumName, SpectralVector{Float64, Vector{Float64}}}()\nnoiseratios = Dict{SpectrumName, SpectralVector{Float64, Vector{Float64}}}()\nidentity_spectrum = SpectralVector(ones(lmax+1));\nnothing #hide","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"The point source holes in the Planck likelihood maps are not sufficiently apodized, which causes problems in the covariance matrix estimation. Recall that we ran signal-only simulations in signalsim.jl so that we could correct for them here. We read in the correction curve estimated in corrections.jl for those simuulations, for use in the covariance matrix.","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"function extend_signal(s::Vector{T}, nside) where T\n    lmax = nside2lmax(nside)\n    es = SpectralVector(zeros(T, lmax+1))\n    for ‚Ñì ‚àà 0:min(length(s) - 1, lmax)\n        es[‚Ñì] = s[‚Ñì+1]\n    end\n    return es\nend\n\nfunction get_correction(freq1, freq2, spec)\n    spec_str = string(spec)\n    if parse(Float64, freq1) > parse(Float64, freq2)\n        freq1, freq2 = freq2, freq1\n        spec_str = reverse(spec_str)\n    end\n    correction_path = joinpath(config[\"scratch\"], \"point_source_corrections\")\n    correction_file = joinpath(correction_path, \"$(freq1)_$(freq2)_$(spec_str)_corr.dat\")\n    correction_gp = readdlm(correction_file)[:,1]\n    correction_gp[1:3] .= 0.0\n    return extend_signal(correction_gp, nside)\nend","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"We want to supply the ratios of the noise power spectrum and the white noise power spectrum. To do that, we need to read in the estimates of the white noise power spectrum that were obtained from the maps.","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"function whitenoiselevel(config, freq::String, split::String)\n    whitenoisefile = joinpath(config[\"scratch\"], \"whitenoise.dat\")\n    df = CSV.read(whitenoisefile, DataFrame)\n    for row in 1:nrow(df)\n        if (string(df[row,:freq]) == freq) && (string(df[row,:split]) == split)\n            return df[row, :noiseT], df[row, :noiseP]\n        end\n    end\n    throw(ArgumentError(\"freq and split combo missing from white noise file\"))\nend","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"We save the noise power spectrum models in terms of parameters of the smooth model fit. We use the expression from CamSpec.","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"@. camspec_model(‚Ñì, Œ±) =  Œ±[1] * (100. / ‚Ñì)^Œ±[2] + Œ±[3] * (‚Ñì / 1000.)^Œ±[4] / ( 1 + (‚Ñì / Œ±[5])^Œ±[6] )^Œ±[7]","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"Now to put it all together. We need to put all of this information into our various dictionaries.","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"ells = collect(0:(lmax))\ncoefficientpath = joinpath(config[\"scratch\"], \"noise_model_coeffs\")\nbeampath = joinpath(config[\"scratch\"], \"beams\")\n\n# loop over combinations and put stuff into the dictionaries\nfor (f1, s1) in zip(freqs, splits)\n    for (f2, s2) in zip(freqs, splits)\n        f1_name = \"P$(f1)hm$(s1)\"\n        f2_name = \"P$(f2)hm$(s2)\"\n        signal, theory_dict = signal_and_theory(f1, f2, config)\n\n        WlTT = util_planck_beam_Wl(f1, \"hm\"*s1, f2, \"hm\"*s2, :TT, :TT;\n            lmax=lmax, beamdir=beampath)\n        WlTE = util_planck_beam_Wl(f1, \"hm\"*s1, f2, \"hm\"*s2, :TE, :TE;\n            lmax=lmax, beamdir=beampath)\n        WlEE = util_planck_beam_Wl(f1, \"hm\"*s1, f2, \"hm\"*s2, :EE, :EE;\n            lmax=lmax, beamdir=beampath)\n\n        spectra[(:TT, f1_name, f2_name)] = extend_signal(signal[\"TT\"], nside) .* WlTT .*\n            sqrt.(1 .+ get_correction(f1, f2, \"TT\"))\n        spectra[(:TE, f1_name, f2_name)] = extend_signal(signal[\"TE\"], nside) .* WlTE .*\n            sqrt.(1 .+ get_correction(f1, f2, \"TE\"))\n        spectra[(:EE, f1_name, f2_name)] = extend_signal(signal[\"EE\"], nside) .* WlEE .*\n            sqrt.(1 .+ get_correction(f1, f2, \"EE\"))\n\n        if f1_name == f2_name\n            whitenoiseT, whitenoiseP = whitenoiselevel(config, f1, s1)\n            coeffTT = readdlm(joinpath(coefficientpath, \"$(run_name)_$(f1)_TT_hm$(s1).dat\"))[:,1]\n            coeffEE = readdlm(joinpath(coefficientpath, \"$(run_name)_$(f1)_EE_hm$(s1).dat\"))[:,1]\n            nlTT = camspec_model(ells, coeffTT)\n            nlEE = camspec_model(ells, coeffEE)\n            ratioTT = SpectralVector(nlTT ./ whitenoiseT)\n            ratioEE = SpectralVector(nlEE ./ whitenoiseP)\n            ratioTT[0:1] .= 1.0\n            ratioEE[0:1] .= 1.0\n            noiseratios[(:TT, f1_name, f2_name)] = sqrt.(ratioTT)\n            noiseratios[(:EE, f1_name, f2_name)] = sqrt.(ratioEE)\n        else\n            noiseratios[(:TT, f1_name, f2_name)] = identity_spectrum\n            noiseratios[(:EE, f1_name, f2_name)] = identity_spectrum\n        end\n    end\nend\n\nfnames = [\"P$(freq)hm$(split)\" for (freq, split) in zip(freqs, splits)]\n\nif \"--plot\" ‚àà ARGS\n    plot(noiseratios[(:TT, fnames[1], fnames[1])].parent, label=\"$(freqs[1]) hm1 TT\")\n    plot!(noiseratios[(:EE, fnames[1], fnames[1])].parent, label=\"$(freqs[1]) hm1 EE\",\n        ylim=(0.0,2), xlim=(0,200), size=(600,300))\nend","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"Each of the four fields involved with the covariance matrix involves a polarized map, with associated mask and variance map. These are packed toegether in the CovField struct in PowerSpectra.jl.","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"# pack all the information that the covmat needs into a structure\nfunction loadcovfield(freq, split)\n    # read maskT, maskP, covariances\n    mapid = \"P$(freq)hm$(split)\"\n    maskfileT = joinpath(config[\"scratch\"], \"masks\", \"$(run_name)_$(mapid)_maskT.fits\")\n    maskfileP = joinpath(config[\"scratch\"], \"masks\", \"$(run_name)_$(mapid)_maskP.fits\")\n    mapfile = joinpath(config[\"scratch\"], \"maps\", config[\"map\"][mapid])\n    maskT = readMapFromFITS(maskfileT, 1, Float64)\n    maskP = readMapFromFITS(maskfileP, 1, Float64)\n    covII = nest2ring(readMapFromFITS(mapfile, 5, Float64)) * 1e12\n    covQQ = nest2ring(readMapFromFITS(mapfile, 8, Float64)) * 1e12\n    covUU = nest2ring(readMapFromFITS(mapfile, 10, Float64)) * 1e12\n    return CovField(mapid, maskT, maskP, PolarizedHealpixMap(covII, covQQ, covUU))\nend\n\nfields = [loadcovfield(freqs[i], splits[i]) for i in 1:4];\nnothing #hide","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"Next, we need to compute the mode-coupling matrices. These are multiplied with the covariance matrices in order to correct for the effects of the mask, just like in the case of the spectra.","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"# compute mode-coupling matrices\nmcm_type_AB = (specAB == :EE) ? :M‚Å∫‚Å∫ : specAB\nmcm_type_CD = (specCD == :EE) ? :M‚Å∫‚Å∫ : specCD\n\n@time M‚ÇÅ‚ÇÇ = mcm(mcm_type_AB, fields[1], fields[2])\n@time M‚ÇÉ‚ÇÑ = mcm(mcm_type_CD, fields[3], fields[4]);\n\n# compute mode-coupled covariance matrix\nworkspace = CovarianceWorkspace(fields...);\n@time C = coupledcov(Symbol(specs[1]*specs[2]), Symbol(specs[3]*specs[4]),\n    workspace, spectra, noiseratios)\n\n\n# this is the product of A and B pixel windows\nfunction spec2pixwin(XY::Symbol, nside)\n    pixwinT, pixwinP = pixwin(nside; pol=true)\n    pixwinP[1:2] .= 1.0\n    pX = (first(string(XY)) == 'T') ? pixwinT : pixwinP\n    pY =  (last(string(XY)) == 'T') ? pixwinT : pixwinP\n    return SpectralVector(pX .* pY)\nend\n\npixwinAB = spec2pixwin(specAB, nside)\npixwinCD = spec2pixwin(specCD, nside)","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"Next, we need decouple the modes from the effect of the mask, correct for the instrumental beam and pixel window function, and then finally bin the covariance matrix.","category":"page"},{"location":"covmat.html","page":"covmat.jl","title":"covmat.jl","text":"# load binnings\nbinfile = joinpath(@__DIR__, \"../\", \"input\", \"binused.dat\")\nP, lb = util_planck_binning(binfile; lmax=lmax)\nbeampath = joinpath(config[\"scratch\"], \"beams\")\n\nC‚ÇÄ = decouple_covmat(C, M‚ÇÅ‚ÇÇ, M‚ÇÉ‚ÇÑ)\nWlAB = util_planck_beam_Wl(freqs[1], \"hm\"*splits[1], freqs[2], \"hm\"*splits[2], specAB, specAB;\n    lmax=lmax, beamdir=beampath)\nWlCD = util_planck_beam_Wl(freqs[3], \"hm\"*splits[3], freqs[4], \"hm\"*splits[4], specCD, specCD;\n    lmax=lmax, beamdir=beampath)\n\nfor l1 in 0:lmax\n    for l2 in 0:lmax\n        C‚ÇÄ[l1, l2] /= WlAB[l1] * WlCD[l2] * pixwinAB[l1] * pixwinCD[l2]\n    end\nend\n\nCbb = P * parent(C‚ÇÄ) * (P')\n\n# transpose if needed, from turning into the canonical form\nif transposed\n    Cbb = Array(transpose(Cbb))\nend\n\nspectrapath = joinpath(config[\"scratch\"], \"rawspectra\")\ncovpath = joinpath(config[\"scratch\"], \"covmatblocks\")\nmkpath(covpath)\n\ncovmat_filename = joinpath(covpath, join(specs) * \"_\" *\n    join(freqs) * \"_\" * join(splits) * \".jld2\")\n@save covmat_filename Cbb","category":"page"},{"location":"fitnoisemodel.html","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov//src/fitnoisemodel.jl\"","category":"page"},{"location":"fitnoisemodel.html","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"# the example command line input for this script\nARGS = [\"example.toml\", \"100\", \"EE\", \"--plot\"]","category":"page"},{"location":"fitnoisemodel.html","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"configfile, freq, spec = ARGS\nif length(ARGS) > 3\n    if ARGS[4] != \"--plot\"\n        maxfuncevals = ARGS[4]\n    else\n        maxfuncevals = 500_000\n    end\nend","category":"page"},{"location":"fitnoisemodel.html#fitnoisemodel","page":"fitnoisemodel.jl","title":"Fit Noise Model (fitnoisemodel.jl)","text":"","category":"section"},{"location":"fitnoisemodel.html","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"# setup data\nusing Plots\nusing TOML\nusing BlackBoxOptim\ninclude(\"util.jl\")\n\nconfig = TOML.parsefile(configfile)\nnside = config[\"general\"][\"nside\"]\nrun_name = config[\"general\"][\"name\"]\nspectrapath = joinpath(config[\"scratch\"], \"rawspectra\")\nXY = Symbol(spec)\nlmax = min(2508, nside2lmax(nside))","category":"page"},{"location":"fitnoisemodel.html","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"Next, we check to see if we need to render plots for the Documentation.","category":"page"},{"location":"fitnoisemodel.html","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"if \"--plot\" ‚àâ ARGS\n    Plots.plot(args...; kwargs...) = nothing\n    Plots.plot!(args...; kwargs...) = nothing\nend\n\n#","category":"page"},{"location":"fitnoisemodel.html","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"We read in the raw spectra generated from rawspectra.jl.","category":"page"},{"location":"fitnoisemodel.html","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"Cl11 = CSV.read(joinpath(spectrapath,\"$(run_name)_P$(freq)hm1xP$(freq)hm1.csv\"), DataFrame);\nCl12 = CSV.read(joinpath(spectrapath,\"$(run_name)_P$(freq)hm1xP$(freq)hm2.csv\"), DataFrame);\nCl22 = CSV.read(joinpath(spectrapath,\"$(run_name)_P$(freq)hm2xP$(freq)hm2.csv\"), DataFrame);\n\ntruncate(vec::AbstractVector, lmax) = SpectralVector(vec[firstindex(vec):(lmax+1)])\ntruncate(vec::SpectralVector, lmax) = vec[IdentityRange(firstindex(vec):lmax)]\n\ncl11 = truncate(Cl11[!,XY], lmax)\ncl12 = truncate(Cl12[!,XY], lmax)\ncl22 = truncate(Cl22[!,XY], lmax)\n\nbeampath = joinpath(config[\"scratch\"], \"beams\")\nWl11 = util_planck_beam_Wl(freq, \"hm1\", freq, \"hm1\", XY, XY;\n    lmax=lmax, beamdir=beampath)\nWl12 = util_planck_beam_Wl(freq, \"hm1\", freq, \"hm2\", XY, XY;\n    lmax=lmax, beamdir=beampath)\nWl22 = util_planck_beam_Wl(freq, \"hm2\", freq, \"hm2\", XY, XY;\n    lmax=lmax, beamdir=beampath)\n\nWl11, Wl12, Wl22 = map(v->truncate(v,lmax), (Wl11, Wl12, Wl22))\n\ncl = cl12 ./ Wl12\nnl1 = (cl11 ./ Wl11 .- cl) .* Wl11\nnl2 = (cl22 ./ Wl22  .- cl) .* Wl22;\n\nell = eachindex(cl)\nplot(ell, ell.^2 .* cl12, label=\"unbeamed $(run_name) $(freq) $(spec)\",\n    xlabel=\"multipole moment\", ylabel=\"\\$\\\\ell^2 C_{\\\\ell}^{$spec}\\$\", xlim=(0,lmax))","category":"page"},{"location":"fitnoisemodel.html","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"@. camspec_model(‚Ñì, Œ±) =\n    Œ±[1] * (100. / ‚Ñì)^Œ±[2] + Œ±[3] * (‚Ñì / 1000.)^Œ±[4] / ( 1 + (‚Ñì / Œ±[5])^Œ±[6] )^Œ±[7]","category":"page"},{"location":"fitnoisemodel.html","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"function fit_bb_model(model, p0, xl, yl, signal; kwargs...)\n    lower = map(x -> x-0.9abs(x), p0)\n    upper = map(x -> x+0.9abs(x), p0)\n    like(Œ±) = (sum((2 .* xl .+ 1) ./ (model(xl, p0).^2 .+ signal.^2) .* (model(xl, Œ±) .- yl).^2))\n    println(\"starting opt \", like(p0))\n    res = bboptimize(like; SearchRange=map((i,j)->(i,j), lower, upper), NumDimensions = length(p0),\n        MaxFuncEvals=maxfuncevals, TraceInterval=20)\n    return best_candidate(res)\nend","category":"page"},{"location":"fitnoisemodel.html","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"p0_1 = readdlm(joinpath(@__DIR__, \"../\", \"input\",\n        \"initial_planck_noise_coeffs\", \"$(freq)_hm1_$(spec)_coeff.dat\"))[:,1]\np0_2 = readdlm(joinpath(@__DIR__, \"../\", \"input\",\n        \"initial_planck_noise_coeffs\", \"$(freq)_hm2_$(spec)_coeff.dat\"))[:,1]","category":"page"},{"location":"fitnoisemodel.html","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"min_ell_ind = 31 # lmin=30\npfit_1 = fit_bb_model(camspec_model, p0_1,\n    parent(ell)[min_ell_ind:end], parent(nl1)[min_ell_ind:end], parent(cl)[min_ell_ind:end])\npfit_2 = fit_bb_model(camspec_model, p0_2,\n    parent(ell)[min_ell_ind:end], parent(nl2)[min_ell_ind:end], parent(cl)[min_ell_ind:end])","category":"page"},{"location":"fitnoisemodel.html","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"mean(x) = sum(x) / length(x)\nplot((nl1), alpha=0.5, label=\"nl hm1\")\nplot!(2:lmax, [camspec_model(‚Ñì, p0_1) for ‚Ñì in 2:lmax], ylim=(0.0, 4mean(abs.(nl1))), label=\"initial model\")\nplot!(2:lmax, [camspec_model(‚Ñì, pfit_1) for ‚Ñì in 2:lmax], label=\"fitted model\", linestyle=:dash)","category":"page"},{"location":"fitnoisemodel.html","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"#\nplot((nl2), alpha=0.5, label=\"nl hm2\")\nplot!(2:lmax, [camspec_model(‚Ñì, p0_2) for ‚Ñì in 2:lmax], ylim=(0.0, 2mean(nl2)), label=\"initial model\")\nplot!(2:lmax, [camspec_model(‚Ñì, pfit_2) for ‚Ñì in 2:lmax], ylim=(0.0, 2mean(nl2)), label=\"fitted model\", linestyle=:dash)","category":"page"},{"location":"fitnoisemodel.html","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"coefficientpath = joinpath(config[\"scratch\"], \"noise_model_coeffs\")\nmkpath(coefficientpath)\n\nopen(joinpath(coefficientpath, \"$(run_name)_$(freq)_$(spec)_hm1.dat\"), \"w\") do io\n   writedlm(io, pfit_1)\nend\nopen(joinpath(coefficientpath, \"$(run_name)_$(freq)_$(spec)_hm2.dat\"), \"w\") do io\n   writedlm(io, pfit_2)\nend","category":"page"},{"location":"whitenoise.html","page":"whitenoise.jl","title":"whitenoise.jl","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov//src/whitenoise.jl\"","category":"page"},{"location":"whitenoise.html","page":"whitenoise.jl","title":"whitenoise.jl","text":"# all examples are run on an example global.toml and downsized maps.\nARGS = [\"example.toml\"]","category":"page"},{"location":"whitenoise.html#whitenoise","page":"whitenoise.jl","title":"White Noise Levels (whitenoise.jl)","text":"","category":"section"},{"location":"whitenoise.html","page":"whitenoise.jl","title":"whitenoise.jl","text":"This file estimates the amplitude of the noise power spectrum from the pixel variance map, under the assumption that the noise is white. We want to compute","category":"page"},{"location":"whitenoise.html","page":"whitenoise.jl","title":"whitenoise.jl","text":"N_ell^mathrmwhite = frac1sum_p m_p^2 sum_p sigma_II^2 Omega_p m_p^2","category":"page"},{"location":"whitenoise.html","page":"whitenoise.jl","title":"whitenoise.jl","text":"where m_p is mask at pixel p, Omega_p is the pixel area, and sigma_II^2 is the pixel variance.","category":"page"},{"location":"whitenoise.html","page":"whitenoise.jl","title":"whitenoise.jl","text":"<pre class=\"shell\">\n<code class=\"language-shell hljs\">$ julia whitenoise.jl example.toml</code></pre>","category":"page"},{"location":"whitenoise.html","page":"whitenoise.jl","title":"whitenoise.jl","text":"We first need to do the usual setup steps. We read the command-line arguments and load the packages we need.","category":"page"},{"location":"whitenoise.html","page":"whitenoise.jl","title":"whitenoise.jl","text":"configfile = first(ARGS)\n\n# setup data\nusing Plots\nusing PowerSpectra\nusing Healpix\nusing TOML\nusing CSV\nusing DataFrames\n\nconfig = TOML.parsefile(configfile)\nnside = config[\"general\"][\"nside\"]\nrun_name = config[\"general\"][\"name\"]\nspectrapath = joinpath(config[\"scratch\"], \"rawspectra\")\nlmax = min(2508,nside2lmax(nside))\nnpix = nside2npix(nside)\nŒ©p = 4œÄ / npix","category":"page"},{"location":"whitenoise.html","page":"whitenoise.jl","title":"whitenoise.jl","text":"Next, we loop over each half-mission frequency map, and estimate the white noise power spectrum.","category":"page"},{"location":"whitenoise.html","page":"whitenoise.jl","title":"whitenoise.jl","text":"df = DataFrame(freq = String[], split = String[], noiseT = Float64[], noiseP = Float64[])\n\nfor freq ‚àà (\"100\", \"143\", \"217\"),  split ‚àà (\"1\", \"2\")\n    mapid = \"P$(freq)hm$(split)\"\n    maskfileT = joinpath(config[\"scratch\"], \"masks\", \"$(run_name)_$(mapid)_maskT.fits\")\n    maskfileP = joinpath(config[\"scratch\"], \"masks\", \"$(run_name)_$(mapid)_maskP.fits\")\n    mapfile = joinpath(config[\"scratch\"], \"maps\", config[\"map\"][mapid])\n    maskT = readMapFromFITS(maskfileT, 1, Float64)\n    maskP = readMapFromFITS(maskfileP, 1, Float64)\n    covII = nest2ring(readMapFromFITS(mapfile, 5, Float64)) * 1e12\n    covQQ = nest2ring(readMapFromFITS(mapfile, 8, Float64)) * 1e12\n    covUU = nest2ring(readMapFromFITS(mapfile, 10, Float64)) * 1e12\n    N_white_T = sum(maskT.pixels.^2 .* (covII.pixels) .* Œ©p) ./ (sum(maskT.pixels.^2))\n    N_white_P = sum(maskP.pixels.^2 .* (covUU.pixels + covQQ.pixels) .* Œ©p) ./ (2 * sum(maskP.pixels.^2))\n    push!(df, (freq, split, N_white_T, N_white_P))\nend","category":"page"},{"location":"whitenoise.html","page":"whitenoise.jl","title":"whitenoise.jl","text":"Finally, we save this all to a CSV.","category":"page"},{"location":"whitenoise.html","page":"whitenoise.jl","title":"whitenoise.jl","text":"csvfile = joinpath(config[\"scratch\"], \"whitenoise.dat\")\nCSV.write(csvfile, df)","category":"page"},{"location":"pipeline.html","page":"Pipeline","title":"Pipeline","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov/docs/src/pipeline.md\"","category":"page"},{"location":"pipeline.html#Pipeline","page":"Pipeline","title":"Pipeline","text":"","category":"section"},{"location":"pipeline.html","page":"Pipeline","title":"Pipeline","text":"The following file lists the shell commands that comprise the pipeline.","category":"page"},{"location":"pipeline.html","page":"Pipeline","title":"Pipeline","text":"<pre class=\"shell\">\n<code class=\"language-shell hljs\">julia src/setup.jl global.toml\n</code></pre>","category":"page"},{"location":"pipeline.html","page":"Pipeline","title":"Pipeline","text":"<pre class=\"shell\">\n<code class=\"language-shell hljs\">sbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P100hm1 P100hm1\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P100hm1 P143hm1\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P100hm1 P143hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P100hm1 P217hm1\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P100hm1 P100hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P100hm1 P217hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm1 P143hm1\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm1 P143hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm1 P217hm1\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm1 P100hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm1 P217hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm2 P143hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm2 P217hm1\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm2 P100hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm2 P217hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P217hm1 P217hm1\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P217hm1 P100hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P217hm1 P217hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P100hm2 P100hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P100hm2 P217hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P217hm2 P217hm2\"\n</code></pre>","category":"page"},{"location":"util.html","page":"util.jl","title":"util.jl","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov//src/util.jl\"","category":"page"},{"location":"util.html#","page":"util.jl","title":"","text":"","category":"section"},{"location":"util.html#util","page":"util.jl","title":"Utilities (util.jl)","text":"","category":"section"},{"location":"util.html","page":"util.jl","title":"util.jl","text":"Unlike every other file in the pipeline, this file is not intended to be run directly. Instead, include this in other files. These utilities provide an interface to the Planck data products, namely","category":"page"},{"location":"util.html","page":"util.jl","title":"util.jl","text":"binning matrix\nbeam W_ell^XY = B_ell^X B_ell^Y\nforeground model cross-spectra\ntextttplic reference covariance matrix and reference spectra, for comparison plots","category":"page"},{"location":"util.html","page":"util.jl","title":"util.jl","text":"using PowerSpectra\nusing DataFrames, CSV\nusing DelimitedFiles\nusing LinearAlgebra\nusing FITSIO","category":"page"},{"location":"util.html#Planck-Binning","page":"util.jl","title":"Planck Binning","text":"","category":"section"},{"location":"util.html","page":"util.jl","title":"util.jl","text":"Planck bins the spectra at the very end, and applies an ell (ell+1) relative weighting inside the bin. This utility function generates the binning operator P_bell such that C_b = P_b ell C_ell. It also returns the mean of the left and right bin edges, which is what is used when plotting the Planck spectra.","category":"page"},{"location":"util.html","page":"util.jl","title":"util.jl","text":"\"\"\"\n    util_planck_binning(binfile; lmax=6143)\n\nObtain the Planck binning scheme.\n\n### Arguments:\n- `binfile::String`: filename of the Planck binning, containing left/right bin edges\n\n### Keywords\n- `lmax::Int=6143`: maximum multipole for one dimension of the binning matrix\n\n### Returns:\n- `Tuple{Matrix{Float64}, Vector{Float64}`: returns (binning matrix, bin centers)\n\"\"\"\nfunction util_planck_binning(binfile; lmax=6143)\n    bin_df = DataFrame(CSV.File(binfile;\n        header=false, delim=\" \", ignorerepeated=true))\n    lb = (bin_df[:,1] .+ bin_df[:,2]) ./ 2\n    P = binning_matrix(bin_df[:,1], bin_df[:,2], ‚Ñì -> ‚Ñì*(‚Ñì+1) / (2œÄ); lmax=lmax)\n    return P, lb[1:size(P,1)]\nend","category":"page"},{"location":"util.html#Planck-Beam","page":"util.jl","title":"Planck Beam","text":"","category":"section"},{"location":"util.html","page":"util.jl","title":"util.jl","text":"The Planck effective beams are azimuthally-averaged window functions induced by the instrumental optics. This utility function reads the Planck beams from the RIMO, which are of the form TT_2_TT, TT_2_EE etc. Conventionally, the Planck spectra are stored with the diagonal of the beam-mixing matrix applied.","category":"page"},{"location":"util.html","page":"util.jl","title":"util.jl","text":"C_ell = W^-1_ell hatC_ell","category":"page"},{"location":"util.html","page":"util.jl","title":"util.jl","text":"\"\"\"\n    util_planck_beam_Wl([T::Type=Float64], freq1, split1, freq2, split2, spec1_, spec2_;\n        lmax=4000, beamdir=nothing)\n\nReturns the Planck beam transfer of [spec1]_to_[spec2], in Wl form.\n\n### Arguments:\n- `T::Type=Float64`: optional first parameter specifying numerical type\n- `freq1::String`: frequency of first field\n- `split1::String`: split of first field (i.e. hm1)\n- `freq2::String`: frequency of first field\n- `split2::String`: split of second field (i.e. hm2)\n- `spec1_`: converted to string, source spectrum like TT\n- `spec2_`: converted to string, destination spectrum\n\n### Keywords\n- `lmax=4000`: maximum multipole\n- `beamdir=nothing`: directory containing beam FITS files. if nothing, will fall back to\n        the PowerSpectra.jl beam files.\n\n### Returns:\n- `SpectralVector`: the beam Wl, indexed 0:lmax\n\"\"\"\nfunction util_planck_beam_Wl(T::Type, freq1, split1, freq2, split2, spec1_, spec2_;\n                        lmax=4000, beamdir=nothing)\n    if isnothing(beamdir)\n        @warn \"beam directory not specified. switching to PowerSpectra.jl fallback\"\n        beamdir = PowerSpectra.planck256_beamdir()\n    end\n    spec1 = String(spec1_)\n    spec2 = String(spec2_)\n\n    if parse(Int, freq1) > parse(Int, freq2)\n        freq1, freq2 = freq2, freq1\n        split1, split2 = split2, split1\n    end\n    if (freq1 == freq2) && ((split1 == \"hm2\") && (split2 == \"hm1\"))\n        split1, split2 = split2, split1\n    end\n\n    fname = \"Wl_R3.01_plikmask_$(freq1)$(split1)x$(freq2)$(split2).fits\"\n    f = FITS(joinpath(beamdir, \"BeamWf_HFI_R3.01\", fname))\n    Wl = convert(Vector{T}, read(f[spec1], \"$(spec1)_2_$(spec2)\")[:,1])\n    if lmax < 4000\n        Wl = Wl[1:lmax+1]\n    else\n        Wl = vcat(Wl, last(Wl) * ones(T, lmax - 4000))\n    end\n    return SpectralVector(Wl)\nend\nutil_planck_beam_Wl(T::Type, freq1, split1, freq2, split2, spec1; kwargs...) =\n    util_planck_beam_Wl(T, freq1, split1, freq2, split2, spec1, spec1; kwargs...)\nutil_planck_beam_Wl(freq1::String, split1, freq2, split2, spec1, spec2; kwargs...) =\n    util_planck_beam_Wl(Float64, freq1, split1, freq2, split2, spec1, spec2; kwargs...)","category":"page"},{"location":"util.html#Planck-Likelihood-Specifics","page":"util.jl","title":"Planck Likelihood Specifics","text":"","category":"section"},{"location":"util.html","page":"util.jl","title":"util.jl","text":"The Planck likelihood uses a specific choice of spectra and multipole ranges for those spectra. We provide some utility functions to retrieve a copy of the spectra order and the multipole minimum and maximum for those spectra.","category":"page"},{"location":"util.html","page":"util.jl","title":"util.jl","text":"plic_order() = (\n    (:TT,\"100\",\"100\"), (:TT,\"143\",\"143\"), (:TT,\"143\",\"217\"), (:TT,\"217\",\"217\"),\n    (:EE,\"100\",\"100\"), (:EE,\"100\",\"143\"), (:EE,\"100\",\"217\"), (:EE,\"143\",\"143\"),\n    (:EE,\"143\",\"217\"), (:EE,\"217\",\"217\"),\n    (:TE,\"100\",\"100\"), (:TE,\"100\",\"143\"), (:TE,\"100\",\"217\"), (:TE,\"143\",\"143\"),\n    (:TE,\"143\",\"217\"), (:TE,\"217\",\"217\")\n)\n\nconst plic_ellranges = Dict(\n    (:TT, \"100\", \"100\") => (30, 1197),\n    (:TT, \"143\", \"143\") => (30, 1996),\n    (:TT, \"143\", \"217\") => (30, 2508),\n    (:TT, \"217\", \"217\") => (30, 2508),\n    (:EE, \"100\", \"100\") => (30, 999),\n    (:EE, \"100\", \"143\") => (30, 999),\n    (:EE, \"100\", \"217\") => (505, 999),\n    (:EE, \"143\", \"143\") => (30, 1996),\n    (:EE, \"143\", \"217\") => (505, 1996),\n    (:EE, \"217\", \"217\") => (505, 1996),\n\n    (:TE, \"100\", \"100\") => (30, 999),\n    (:TE, \"100\", \"143\") => (30, 999),\n    (:TE, \"100\", \"217\") => (505, 999),\n    (:TE, \"143\", \"143\") => (30, 1996),\n    (:TE, \"143\", \"217\") => (505, 1996),\n    (:TE, \"217\", \"217\") => (505, 1996),\n\n    (:TT, \"100\", \"143\") => (30, 999),   # not used\n    (:TT, \"100\", \"217\") => (505, 999),  # not used\n)\n\nfunction get_plic_ellrange(spec::Symbol, freq1, freq2)\n    if spec ‚àà (:TE, :ET)\n        if parse(Float64, freq1) > parse(Float64, freq2)\n            freq1, freq2 = freq2, freq1\n        end\n        return plic_ellranges[:TE, freq1, freq2]\n    end\n    return plic_ellranges[spec, freq1, freq2]\nend","category":"page"},{"location":"util.html#Signal-Spectra","page":"util.jl","title":"Signal Spectra","text":"","category":"section"},{"location":"util.html","page":"util.jl","title":"util.jl","text":"The covariance matrix calculation and and signal simulations require an assumed signal spectra. We use the same foreground spectra as used in the textplic likelihood. This returns dictionaries for signal and theory C_ell in mumathrmK between two frequencies. The data is stored in the plicref directory in the config.","category":"page"},{"location":"util.html","page":"util.jl","title":"util.jl","text":"function signal_and_theory(freq1, freq2, config::Dict)\n    likelihood_data_dir = joinpath(config[\"scratch\"], \"plicref\")\n    th = read_commented_header(joinpath(likelihood_data_dir,\"theory_cl.txt\"))\n    fg = read_commented_header(joinpath(likelihood_data_dir,\n        \"base_plikHM_TTTEEE_lowl_lowE_lensing.minimum.plik_foregrounds\"))\n\n    for (spec, f1, f2) in plic_order()\n        lmin, lmax = get_plic_ellrange(spec, f1, f2)\n        const_val = fg[lmax-1,\"$(spec)$(f1)X$(f2)\"]\n        # constant foreground level after lmax -- there are fitting artifacts otherwise\n        fg[(lmax-1):end, \"$(spec)$(f1)X$(f2)\"] .= const_val\n    end\n\n    # loop over spectra and also fill in the flipped name\n    freqs = (\"100\", \"143\", \"217\")\n    specs = (\"TT\", \"TE\", \"ET\", \"EE\")\n    for f1 in freqs, f2 in freqs, spec in specs\n        if \"$(spec)$(f1)X$(f2)\" ‚àâ names(fg)\n            if \"$(reverse(spec))$(f2)X$(f1)\" ‚àà names(fg)\n                fg[!, \"$(spec)$(f1)X$(f2)\"] = fg[!, \"$(reverse(spec))$(f2)X$(f1)\"]\n            else\n                fg[!, \"$(spec)$(f1)X$(f2)\"] = zeros(nrow(fg))\n            end\n        end\n    end\n\n    ap(v) = vcat([0., 0.], v)\n    ell_fac = fg[!, \"l\"] .* (fg[!, \"l\"] .+ 1) ./ (2œÄ);\n    signal_dict = Dict{String,Vector{Float64}}()\n    theory_dict = Dict{String,Vector{Float64}}()\n\n    for XY‚ÇÄ in specs  ## XY‚ÇÄ is the spectrum to store\n        f‚ÇÅ, f‚ÇÇ = parse(Int, freq1), parse(Int, freq2)\n        if f‚ÇÅ <= f‚ÇÇ\n            XY = XY‚ÇÄ\n        else  ## swap what we're looking for, as fg data only has those cross-spectra\n            XY = XY‚ÇÄ[2] * XY‚ÇÄ[1]\n            f‚ÇÅ, f‚ÇÇ = f‚ÇÇ, f‚ÇÅ\n        end\n        if XY == \"ET\"\n            theory_cl_XY = th[!, \"TE\"] ./ (th[!, \"L\"] .* (th[!, \"L\"] .+ 1) ./ (2œÄ))\n        else\n            theory_cl_XY = th[!, XY] ./ (th[!, \"L\"] .* (th[!, \"L\"] .+ 1) ./ (2œÄ))\n        end\n        fg_cl_XY = fg[!, \"$(XY)$(f‚ÇÅ)X$(f‚ÇÇ)\"] ./ (fg[!, \"l\"] .* (fg[!, \"l\"] .+ 1) ./ (2œÄ))\n\n        signal_dict[XY‚ÇÄ] =  ap(theory_cl_XY .+ fg_cl_XY[1:2507])\n        theory_dict[XY‚ÇÄ] =  ap(theory_cl_XY)\n    end\n    return signal_dict, theory_dict\nend","category":"page"},{"location":"util.html#Planck-\\texttt{plic}-Reference","page":"util.jl","title":"Planck textttplic Reference","text":"","category":"section"},{"location":"util.html","page":"util.jl","title":"util.jl","text":"In various parts of the pipeline, we want to compare our results to the official 2018 data release. These routines load them from disk. They're automatically downloaded to the plicref directory specified in the configuration TOML.","category":"page"},{"location":"util.html","page":"util.jl","title":"util.jl","text":"\"\"\"\n    PlanckReferenceCov(plicrefpath::String)\n\nStores the spectra and covariances of the reference plic analysis.\n\"\"\"\nPlanckReferenceCov\n\nstruct PlanckReferenceCov{T}\n    cov::Array{T,2}\n    ells::Vector{Int}\n    cls::Vector{T}\n    keys::Vector{String}\n    sub_indices::Vector{Int}\n    key_index_dict::Dict{String,Int}\nend\n\nfunction PlanckReferenceCov(plicrefpath)\n    ellspath = joinpath(plicrefpath, \"vec_all_spectra.dat\")\n    clpath = joinpath(plicrefpath, \"data_extracted.dat\")\n    covpath = joinpath(plicrefpath, \"covmat.dat\")\n    keys = [\"TT_100x100\", \"TT_143x143\", \"TT_143x217\", \"TT_217x217\", \"EE_100x100\",\n        \"EE_100x143\", \"EE_100x217\", \"EE_143x143\", \"EE_143x217\", \"EE_217x217\", \"TE_100x100\",\n        \"TE_100x143\", \"TE_100x217\", \"TE_143x143\", \"TE_143x217\", \"TE_217x217\"]\n    cov = inv(readdlm(covpath))\n    ells = readdlm(ellspath)[:,1]\n    cls = readdlm(clpath)[:,2]\n\n    subarray_indices = collect(0:(size(cov,1)-2))[findall(diff(ells) .< 0) .+ 1] .+ 1\n    sub_indices = [1, subarray_indices..., length(cls)+1]\n    key_ind = 1:length(keys)\n    key_index_dict = Dict(keys .=> key_ind)\n\n    return PlanckReferenceCov{Float64}(cov, ells, cls, keys, sub_indices, key_index_dict)\nend\n\n\n\"\"\"\n    get_subcov(pl::PlanckReferenceCov, spec1, spec2)\n\nExtract the sub-covariance matrix corresponding to spec1 √ó spec2.\n\n### Arguments:\n- `pl::PlanckReferenceCov`: data structure storing reference covmat and spectra\n- `spec1::String`: spectrum of form i.e. \"TT_100x100\"\n- `spec2::String`: spectrum of form i.e. \"TT_100x100\"\n\n### Returns:\n- `Matrix{Float64}`: subcovariance matrix\n\"\"\"\nfunction get_subcov(pl::PlanckReferenceCov, spec1, spec2)\n    i = pl.key_index_dict[spec1]\n    j = pl.key_index_dict[spec2]\n    return pl.cov[\n        pl.sub_indices[i] : (pl.sub_indices[i + 1] - 1),\n        pl.sub_indices[j] : (pl.sub_indices[j + 1] - 1),\n    ]\nend\n\n\"\"\"\n    extract_spec_and_cov(pl::PlanckReferenceCov, spec1)\n\nExtract the reference ells, cl, errorbar, and sub-covariance block for a spectrum √ó itself.\n\n### Arguments:\n- `pl::PlanckReferenceCov`: data structure storing reference covmat and spectra\n- `spec1::String`: spectrum of form i.e. \"TT_100x100\"\n\n### Returns:\n- `(ells, cl, err, this_subcov)`\n\"\"\"\nfunction extract_spec_and_cov(pl::PlanckReferenceCov, spec1)\n    i = pl.key_index_dict[spec1]\n    this_subcov = get_subcov(pl, spec1, spec1)\n    ells = pl.ells[pl.sub_indices[i]:(pl.sub_indices[i + 1] - 1)]\n    cl = pl.cls[pl.sub_indices[i]:(pl.sub_indices[i + 1] - 1)]\n    err = sqrt.(diag(this_subcov))\n    return ells, cl, err, this_subcov\nend","category":"page"},{"location":"slurmgen.html","page":"slurmgen.jl","title":"slurmgen.jl","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov//src/slurmgen.jl\"","category":"page"},{"location":"slurmgen.html","page":"slurmgen.jl","title":"slurmgen.jl","text":"# all examples are run on an example global.toml and downsized maps.\nARGS = [\"example.toml\"]","category":"page"},{"location":"slurmgen.html","page":"slurmgen.jl","title":"slurmgen.jl","text":"configfile = ARGS[1]","category":"page"},{"location":"slurmgen.html#","page":"slurmgen.jl","title":"","text":"","category":"section"},{"location":"slurmgen.html#slurmgen","page":"slurmgen.jl","title":"SLURM Commands for Spectra (slurmgen.jl)","text":"","category":"section"},{"location":"slurmgen.html","page":"slurmgen.jl","title":"slurmgen.jl","text":"This command generates SLURM commands that executes rawspectra.jl on all the pairs of maps in the config.","category":"page"},{"location":"slurmgen.html","page":"slurmgen.jl","title":"slurmgen.jl","text":"# this file just prints out the SLURM commands required to compute the spectra\nusing TOML\nconfig = TOML.parsefile(configfile)","category":"page"},{"location":"slurmgen.html","page":"slurmgen.jl","title":"slurmgen.jl","text":"Let's generate the commands we need for likelihood spectra.","category":"page"},{"location":"slurmgen.html","page":"slurmgen.jl","title":"slurmgen.jl","text":"mapids = [k for k in keys(config[\"map\"])]\ncmd = \"sbatch scripts/8core2hr.cmd\"\nfor i in 1:length(mapids)\n    for j in i:length(mapids)\n        println(\"$(cmd) \\\"julia src/rawspectra.jl $(configfile) $(mapids[i]) $(mapids[j])\\\"\")\n    end\nend","category":"page"},{"location":"slurmgen.html","page":"slurmgen.jl","title":"slurmgen.jl","text":"I just paste these in and wait a few hours. The resulting spectra are deposited in the scratch dir in the config.","category":"page"},{"location":"slurmgen.html#Fit-Noise-Model","page":"slurmgen.jl","title":"Fit Noise Model","text":"","category":"section"},{"location":"slurmgen.html","page":"slurmgen.jl","title":"slurmgen.jl","text":"These SLURM commands fit the raw spectra with the camspec noise model.","category":"page"},{"location":"slurmgen.html","page":"slurmgen.jl","title":"slurmgen.jl","text":"# loop over freqs and noise channels\nprintln()\nfor freq in (\"100\", \"143\", \"217\")\n    for spec in (\"TT\", \"EE\")\n        println(\"$(cmd) \\\"julia src/fitnoisemodel.jl $(configfile) $(freq) $(spec)\\\"\")\n    end\nend","category":"page"},{"location":"slurmgen.html#Generating-Signal-Only-Simulations","page":"slurmgen.jl","title":"Generating Signal-Only Simulations","text":"","category":"section"},{"location":"slurmgen.html","page":"slurmgen.jl","title":"slurmgen.jl","text":"These SLURM commands correct the covariances for the insufficiently-apodized point source holes.","category":"page"},{"location":"slurmgen.html","page":"slurmgen.jl","title":"slurmgen.jl","text":"# loop over freqs and noise channels\nprintln()\ncmd = \"sbatch scripts/8core2hr.cmd\"\nfreqs = (\"100\", \"143\", \"217\")\nfor i in 1:3\n    for j in i:3\n        for spec in (\"TT\", \"TE\", \"ET\", \"EE\")\n            freq1, freq2 = freqs[i], freqs[j]\n            println(\"$(cmd) \\\"julia src/signalsim.jl $(configfile) $(freq1) $(freq2) $(spec) 5000\\\"\")\n        end\n    end\nend","category":"page"},{"location":"slurmgen.html#Fit-Signal-Only-Simulation-Corrections","page":"slurmgen.jl","title":"Fit Signal-Only Simulation Corrections","text":"","category":"section"},{"location":"slurmgen.html","page":"slurmgen.jl","title":"slurmgen.jl","text":"These SLURM commands correct the covariances for the insufficiently-apodized point source holes.","category":"page"},{"location":"slurmgen.html","page":"slurmgen.jl","title":"slurmgen.jl","text":"# loop over freqs and noise channels\nprintln()\nfreqs = (\"100\", \"143\", \"217\")\nfor i in 1:3\n    for j in i:3\n        for spec in (\"TT\", \"TE\", \"ET\", \"EE\")\n            freq1, freq2 = freqs[i], freqs[j]\n            println(\"$(cmd) \\\"julia src/corrections.jl $(configfile) $(freq1) $(freq2) $(spec)\\\"\")\n        end\n    end\nend\n\n#\nfunction unique_splits(X, Y, f1, f2)\n    if (X == Y) && (f1 == f2)\n        return [(1,2)]\n    elseif (X==Y) && (f1 != f2)\n        return [(1,2), (2,1)]\n    else\n        return [(1,1), (1,2), (2,1), (2,2)]\n    end\nend\n\nusing Test\nusing Base.Iterators\n\n@test unique_splits(\"T\", \"T\", \"100\", \"100\") == [(1,2)]\n@test unique_splits(\"T\", \"E\", \"100\", \"100\") == [(1,1), (1,2), (2,1), (2,2)]\n@test unique_splits(\"T\", \"T\", \"100\", \"143\") == [(1,2), (2,1)]\n@test unique_splits(\"E\", \"E\", \"100\", \"143\") == [(1,2), (2,1)]\n@test unique_splits(\"T\", \"E\", \"100\", \"143\") == [(1,1), (1,2), (2,1), (2,2)]\n\ninclude(\"util.jl\")\nspecs = (\n    (:TT,\"100\",\"100\"), (:TT,\"143\",\"143\"), (:TT,\"143\",\"217\"), (:TT,\"217\",\"217\"),\n    (:EE,\"100\",\"100\"), (:EE,\"100\",\"143\"), (:EE,\"100\",\"217\"), (:EE,\"143\",\"143\"),\n    (:EE,\"143\",\"217\"), (:EE,\"217\",\"217\"),\n    (:TE,\"100\",\"100\"), (:TE,\"100\",\"143\"), (:TE,\"100\",\"217\"), (:TE,\"143\",\"143\"),\n    (:TE,\"143\",\"217\"), (:TE,\"217\",\"217\"),\n    (:ET,\"100\",\"143\"), (:ET,\"100\",\"217\"), (:ET,\"143\",\"217\")  # combined with TE in plic\n)\n\nconstituents = []\n\nfor spec in specs\n    AB, f1, f2 = spec\n    A, B = string(AB)\n    for (s1, s2) in unique_splits(A, B, f1, f2)\n        push!(constituents, (A, B, f1, f2, s1, s2))\n    end\nend\n\nrun_name = config[\"general\"][\"name\"]\ncmd = \"sbatch scripts/8core2hr.cmd\"\nscriptpath = joinpath(config[\"scratch\"], \"scripts\")\nmkpath(scriptpath)\nopen(joinpath(scriptpath, \"$(run_name)_gen_covmats.sh\"), \"w\") do f\n    nspecs = length(constituents)\n\n    # generate the upper triangle\n    for i1 in 1:nspecs\n        for i2 in i1:nspecs\n            A, B, f1, f2, s1, s2 = constituents[i1]\n            C, D, f3, f4, s3, s4 = constituents[i2]\n            write(f, \"$(cmd) \\\"julia src/covmat.jl $(configfile) $f1 $f2 $f3 $f4 $A $B $C $D $s1 $s2 $s3 $s4\\\"\\n\")\n        end\n    end\nend","category":"page"},{"location":"signalsim.html","page":"signalsim.jl","title":"signalsim.jl","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov//src/signalsim.jl\"","category":"page"},{"location":"signalsim.html","page":"signalsim.jl","title":"signalsim.jl","text":"# the example command line input for this script\nARGS = [\"example.toml\",  \"143\", \"143\", \"TT\", \"10\", \"--plot\"]","category":"page"},{"location":"signalsim.html","page":"signalsim.jl","title":"signalsim.jl","text":"configfile, freq1, freq2, spec, nsims = ARGS","category":"page"},{"location":"signalsim.html#signalsim","page":"signalsim.jl","title":"Signal Sims (signalsim.jl)","text":"","category":"section"},{"location":"signalsim.html","page":"signalsim.jl","title":"signalsim.jl","text":"This script runs signal simulations.","category":"page"},{"location":"signalsim.html","page":"signalsim.jl","title":"signalsim.jl","text":"using TOML\nusing Plots\nusing Healpix\nusing JLD2, UUIDs  # for saving sim arrays\ninclude(\"util.jl\")\n\nconfig = TOML.parsefile(configfile)\nnside = config[\"general\"][\"nside\"]\nrun_name = config[\"general\"][\"name\"]\nspectrapath = joinpath(config[\"scratch\"], \"rawspectra\")\nlmax = nside2lmax(nside)\nlmax_planck = min(2508, lmax)\nsplits = \"1\", \"2\"  # planck never uses any other splits","category":"page"},{"location":"signalsim.html","page":"signalsim.jl","title":"signalsim.jl","text":"signal11, th = signal_and_theory(freq1, freq1, config)\nsignal12, th = signal_and_theory(freq1, freq2, config)\nsignal22, th = signal_and_theory(freq2, freq2, config)\nsignal = Dict((\"1\", \"1\") => signal11, (\"1\", \"2\") => signal12, (\"2\", \"2\") => signal22)\n\nùêÇ = zeros(2, 2, lmax+1)\nX, Y = spec\ninds = 1:(lmax_planck+1)\nùêÇ[1,1,inds] .= signal[splits[1], splits[1]][X * X][inds]\nùêÇ[1,2,inds] .= signal[splits[1], splits[2]][X * Y][inds]\nùêÇ[2,1,inds] .= signal[splits[1], splits[2]][X * Y][inds]\nùêÇ[2,2,inds] .= signal[splits[2], splits[2]][Y * Y][inds];\nnothing #hide","category":"page"},{"location":"signalsim.html","page":"signalsim.jl","title":"signalsim.jl","text":"Next, we generate the mode-coupling matrix.","category":"page"},{"location":"signalsim.html","page":"signalsim.jl","title":"signalsim.jl","text":"m1 = PolarizedHealpixMap{Float64, RingOrder}(nside)\nm2 = PolarizedHealpixMap{Float64, RingOrder}(nside)\na1 = [Alm(lmax, lmax) for i in 1:3]\na2 = [Alm(lmax, lmax) for i in 1:3]\n\nX, Y = Symbol(spec[1]), Symbol(spec[2])\nrun_name = config[\"general\"][\"name\"]\nmasktype1 = (X == :T) ? \"T\" : \"P\"\nmasktype2 = (Y == :T) ? \"T\" : \"P\"\nmapid1 = \"P$(freq1)hm$(splits[1])\"\nmapid2 = \"P$(freq2)hm$(splits[2])\"\n\nmaskfile1 = joinpath(config[\"scratch\"], \"masks\", \"$(run_name)_$(mapid1)_mask$(masktype1).fits\")\nmaskfile2 = joinpath(config[\"scratch\"], \"masks\", \"$(run_name)_$(mapid2)_mask$(masktype2).fits\")\nmask1 = readMapFromFITS(maskfile1, 1, Float64)\nmask2 = readMapFromFITS(maskfile2, 1, Float64)\n\nif spec == \"EE\"\n    @time M = mcm(:EE_BB, map2alm(mask1), map2alm(mask2))\nelse\n    @time M = mcm(Symbol(X,Y), map2alm(mask1), map2alm(mask2))\nend","category":"page"},{"location":"signalsim.html","page":"signalsim.jl","title":"signalsim.jl","text":"# map T,E,B => 1,2,3\nchannelindex(X) = findfirst(first(X), \"TEB\")\n\nfunction sim_iteration(ùêÇ, m1, m2, a1, a2, M, spec::String)\n    # get indices of the spectrum\n    c‚ÇÅ, c‚ÇÇ = channelindex(spec[1]), channelindex(spec[2])\n\n    # zero out alms\n    for i in 1:3\n        fill!(a1[i].alm, 0.0)\n        fill!(a2[i].alm, 0.0)\n    end\n\n    # synthesize polarized spectrum into m1\n    synalm!(ùêÇ, [a1[c‚ÇÅ], a2[c‚ÇÇ]])\n    alm2map!(a1, m1)\n    alm2map!(a2, m2)\n\n    # same signal, but different masks\n    mask!(m1, mask1, mask1)\n    mask!(m2, mask2, mask2)\n\n    # subtract monopole if TT\n    if spec[1] == 'T'\n        monopole, dipole = fitdipole(m1.i * mask1)\n        subtract_monopole_dipole!(m1.i, monopole, dipole)\n    end\n    if spec[2] == 'T'\n        monopole, dipole = fitdipole(m2.i * mask2)\n        subtract_monopole_dipole!(m2.i, monopole, dipole)\n    end\n\n    # apply pixel weights and then map2alm\n    Healpix.applyFullWeights!(m1)\n    Healpix.applyFullWeights!(m2)\n    map2alm!(m1, a1; niter=0)\n    map2alm!(m2, a2; niter=0)\n\n    if spec == \"EE\"\n        pCl_EE = SpectralVector(alm2cl(a1[c‚ÇÅ], a2[c‚ÇÇ]))\n        pCl_BB = SpectralVector(zeros(length(pCl_EE)))\n        @spectra Cl_EE, Cl_BB = M \\ [pCl_EE; pCl_BB]\n        return Cl_EE\n    end\n\n    # otherwise easy mode coupling\n    pCl_XY = SpectralVector(alm2cl(a1[c‚ÇÅ], a2[c‚ÇÇ]))\n    return M \\ pCl_XY\nend\n\nif \"--plot\" in ARGS\n    @time simTT = sim_iteration(ùêÇ, m1, m2, a1, a2, M, \"TT\")\n    plot(simTT .* eachindex(simTT).^2, label=\"sim\")\n    plot!(signal12[\"TT\"][1:(lmax_planck+1)] .* eachindex(0:lmax_planck).^2,\n        xlim=(0,lmax_planck), label=\"input\")\nend","category":"page"},{"location":"signalsim.html","page":"signalsim.jl","title":"signalsim.jl","text":"This script generates many simulations.","category":"page"},{"location":"signalsim.html","page":"signalsim.jl","title":"signalsim.jl","text":"simpath = joinpath(config[\"scratch\"], \"signalsims\", \"$(freq1)_$(freq2)_$(spec)\")\nmkpath(simpath)\n\nfor sim_index in 1:parse(Int,nsims)\n    @time cl = sim_iteration(ùêÇ, m1, m2, a1, a2, M, spec)\n    @save \"$(simpath)/$(uuid4()).jld2\" cl=cl\nend","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov/docs/src/index.md\"","category":"page"},{"location":"index.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This is a Simons Observatory pipeline for computing the spectra and covariances of the Planck 2018 high-ell likelihood. Default settings have been chosen to reproduce the official textttplic analysis. The code is also described in Li et al. (in prep). Each page is directly generated from a source file used in the pipeline, in the style of literate programming. Each source file can be located on the PSPipe GitHub using the Edit on GitHub link on the top of every page.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"All executed code within a pipeline component is displayed in light orange code blocks.\nComments in the pipeline components are rendered as markdown.\nThe rendered pages are run on low-resolution Planck 2018 half-mission maps and masks at 143 GHz, generated by averaging down to n_mathrmside = 256.\nAt the top of each page, we provide examples for how to run the pipeline component on the Planck data.\nFor the full analysis described in Li et al. (in prep), consult the pages on Slurm files and cluster use.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The map/alm handling routines for this project were contributed into the Healpix.jl package, and the mode-coupling and covariance matrix calculations were added to PowerSpectra.jl. This pipeline mostly wrangles data and calls the routines from those packages.","category":"page"},{"location":"index.html#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The pipeline operates on the Planck maps, and generates estimates of the spectra and  covariances. A pipeline really boils down to a series of command-line arguments which one executes on some computing cluster with a job manager like SLURM. The files in this  pipeline are generally written to be executed with some command-line arguments.  Each step of this pipeline will look something like","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"<pre class=\"shell\">\n<code class=\"language-shell hljs\">$ julia scriptname.jl example.toml [more arguments...]</code></pre>","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We now provide a review of the different steps that go into this spectrum pipeline.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"setup downloads the Planck data, and also sets up some packages. This requires an internet connection, so you would typically run this on a head node.\nrawspectra computes the basic spectra, by performing mode-decoupling on the pseudo-C_ell. This step also combines the missing pixels and the input likelihood mask, which it saves. These combined masks are used hereafter.\nfitnoisemodel estimates the noise power spectrum from the difference between the auto- and cross-spectra of the half-mission frequency maps. It then fits a smooth model to the estimated spectrum.\nsignalsim generates spectra from signal-only simulations, which are used to correct for the effect of insufficiently-apodized point source holes in the mask.\ncorrections computes the correction to the covariance matrix obtained from the signal-only simulations in signalsim.\nwhitenoise estimates the noise power spectrum if the Planck noise was white, from the pixel variance maps.\ncovmat computes covariance matrices between different spectra in the likelihood data vector, using as inputs the noise model from noisemodel, the corrections from the signal simulations in corrections, and the white-noise levels found in whitenoise. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Lists of commands used to run this pipeline with the job manager SLURM are available in slurmgen.","category":"page"}]
}
